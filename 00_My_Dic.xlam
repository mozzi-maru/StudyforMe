''' 셀 복사하기(Copy)
''   range("A1").copy

''' 셀 선택하기(Select)
''   range("A1").select

''' 셀 이동하기(Offset)
''   range("A1").offset(0,1)
''   offset(안의 숫자는 행, 열 순서로 이동)

''' 현재 활성화된 워크시트를 지칭하기(Activesheet)
''   Activesheet.Range("A1")


''' 현재 선택된 셀부터 전체 셀 선택하기(CurrentRegion)
''   Range("A1").CurrentRegion

''' 중복제거하기
''   Range("H:H").RemoveDuplications columns:=1 Header:=xlNo
'       columns:=숫자 -> 열 갯수

''' if 구문

' if 조건식 then
'   명령어
' else <- 위의 조건식이 거짓이라면(일치하지 않는다면)
'   명령어
' end if <- 반드시 써야함!


''' for 구문
'   for 인수 = 정수(부터) to 정수(까지)
'       명령문
'   next <- 반드시 입력해야 끝임을 알 수 있음!


''' 반복문 끝내기(C언어의 Break)
'   for a = 1 to 2
'       명령문
'   exit for
'   next

'       Exit for -> for 구문 끝내기
'       Exit funtion -> 함수 끝내기
'       Exit sub -> 프로시저 끝내기

''' 정렬하기(Sort)
''   dim inta    as integer
''   dim rangA   as range

''       set rangA = range("A1:AB100")      ==> 반드시 범위설정이 필요!

''  rangA.sort key1:=range("B1"), order1:= xlAscending, _ #언더바로 줄바꿈선언 하는게 좋음
''              key2:=range("C1"), order2:= xlDecending, Header:=xlNo
'       -> key : 제목이 될 부분 => key1, key2, key3 ...
'       -> order : 조건식(내림차순이나 오름차순을 선택) => order1, order2, order3 ...
'       -> xlAscending => 오름차순
'       -> xlDecending => 내림차순
'       ->  Header => 해당 셀(위 식에서는 B1)은 제목인가? 헤더는 Sort문의 가장 마지막에만 와야한다.
'           -> Header:=xlGuess(엑셀 스스로 판단) xlYes(제목이다. 데이터로 취급 안함) xlNo(데이터이다)


''' 고급필터
''  rngD.AdvancedFilter xlFilterCopy, rngC, rngP, True
'        ->  xlFilterInPlace : 원본 범위에서 필터링 할것인가?
'        ->  xlFilterCopy    : 새로운 필드범위에서 필터링 할 것인가?
'        ->  조건범위, (xlFilterCopy의 경우)새로 붙여넣을 범위, 중복제거 여부를 묻는 순서로 이루어짐.
'        ->  조건범위, 대상범위를 잡을 때 위의 제목들도 보통 같이 설정. 그리고 데이터 항목의 내용이 완전히 일치해야 함.

'''   펑션 기능 활용
''    Private Function Data_Check_Color() As String
' 해당 인스턴스 내에서만 활용하는 펑션으로 Data_Check_Color라는 펑션은 스트링 타입으로 받겠다.

''    Dim txtError        As String
''
''    txtError = ""
''
''    If Me.Tb_Name = "" Then
''        txtError = "성명 누락"
''        Me.Tb_Name.BackColor = vbRed
''    Else
''        Me.Tb_Name.BackColor = vbWhite
''    End If
''
''    If Me.Cb_MF = "" Then
''        txtError = txtError & vbCr & "성별 누락"
''        Me.Cb_MF.BackColor = vbRed
''    Else
''        Me.Cb_MF.BackColor = vbWhite
''    End If
''
''    If Me.Tb_Age = "" Then
''        txtError = txtError & vbCr & "나이 누락"
''        Me.Tb_Age.BackColor = vbRed
''    ElseIf Not IsNumeric(Me.Tb_Age) Then
''        txtError = txtError & vbCr & "나이는 숫자만 입력"
''        Me.Tb_Age.BackColor = vbRed
''    Else
''        Me.Tb_Age.BackColor = vbWhite
''    End If
''
''    Data_Check_Color = txtError
''
''End Function

' 펑션 기능은 C언어에서의 return과 유사한 의미




''' PDF로 파일 저장하기
''  dim strPath as string
''  dim strFile as string
''  dim strSave as string

''  strPath = "Dir"
''  strFile = "FileName_" & format(Date, "YYMMDD")
''  strSave = srtPath & strFile & ".pdf"

''  Sheet1.ExportAsFixedFormat _
''
'                    저장하고자 하는 파일 확장자는 무엇인가
''                    Type:=xlTypePDF, _
'                    저장하고자 하는 파일의 이름은 무엇인가
''                    Filename:=strSave, _
'                    저장하고자 하는 파일의 품질은 어떻게 할 것인가
''                    Quality:=xlQualityStandard, _
'                    파일에 대한 속성을 포함해서 저장할 것인가?(맞다면 True)
''                    IncludeDocProperties:=True, _
'                    전체 페이지를 저장할 것인가?(맞다면 False, 아니라면 아래와 같이{From=시작하는 페이지 To=마지막 페이지})
''                    IgnorePrintAreas:=True, _
''                    From:=1, _
''                    To:=1, _
'                    저장하기 전에 미리보기를 열 것인가?(열 것이라면 True, 아니라면 False)
''                    OpenAfterPublish:=False
                    
                    
''' Like 구문으로 분류하기
''  For i = 1 To lengthText
'     한글 찾기
''     If Mid(Range("E2"), i, 1) Like "[ㄱ-흫]" Then
''          hangul = hangul + 1
'     영문 소문자 찾기
''      ElseIf Mid(Range("e2"), i, 1) Like "[a-z]" Then
''          englishsmall = englishsmall + 1
'     영문 대문자 찾기
''      ElseIf Mid(Range("E2"), i, 1) Like "[A-Z]" Then
''          englishbig = englishbig + 1
'     숫자 찾기
''      ElseIf Mid(Range("E2"), i, 1) Like "[0-9]" Then
'     나머지 찾기
''      Else
''      End If
''    Next i
